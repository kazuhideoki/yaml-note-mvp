# 実装手順: フェーズ6a - md<->yaml 変換 API

## 概要

フェーズ6aでは、Markdown 形式のテキストと YAML 形式のデータを相互に変換する API を実装します。これにより、ユーザーが Markdown エディタで編集した内容を YAML 形式で保存したり、YAML データを Markdown として表示したりすることが可能になります。

## 達成基準

- `md_to_yaml` と `yaml_to_md` の実装（Rust）
- ラウンドトリップ変換の単体テスト実装
- `cargo test md_roundtrip` がパスすること

## 必要な依存関係

```toml
[dependencies]
pulldown-cmark = "0.9.2"  # Markdownパーサー
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"
serde_json = "1.0"
wasm-bindgen = "0.2"
```

## 実装手順

### 1. `md_transform.rs` モジュールの作成

まず、`packages/core-wasm/src/` ディレクトリに新しく `md_transform.rs` ファイルを作成し、Markdown <-> YAML 変換機能を実装します：

```rust
//! md_transform.rs
//!
//! Markdown形式とYAML形式の相互変換を行うモジュール。
//! - Markdownテキスト → YAML構造データの変換
//! - YAML構造データ → Markdownテキストの変換
//! - ヘッダー部分とコンテンツ部分の分離・結合処理

use pulldown_cmark::{Parser, Event, Tag};
use serde_json::Value;
use crate::error::{ErrorInfo, ValidationResult};

/// Markdownテキストを解析してYAML文字列に変換する
///
/// # 引数
/// * `md_str` - 変換元のMarkdown文字列
///
/// # 戻り値
/// * 成功時: YAML形式の文字列
/// * 失敗時: エラー情報を含むJSON文字列
///
/// # 動作概要
/// 1. Markdownをパースして構造を解析
/// 2. ヘッダーとコンテンツを分離
/// 3. コンテンツを適切にYAML化
/// 4. ヘッダー情報とマージして完全なYAMLを構築
pub fn md_to_yaml(md_str: &str) -> String {
    // 基本的な実装例：
    // この例では、最初の見出しをタイトルとして扱い、残りのコンテンツを「content」フィールドに入れる
    let mut title = String::new();
    let mut content = String::new();
    let mut in_title = false;
    
    // Markdownのパース
    let parser = Parser::new(md_str);
    
    for event in parser {
        match event {
            Event::Start(Tag::Heading(1)) => {
                in_title = true;
            },
            Event::Text(text) if in_title && title.is_empty() => {
                title = text.to_string();
            },
            Event::End(Tag::Heading(1)) => {
                in_title = false;
            },
            _ if !in_title => {
                // タイトル以外のすべてのコンテンツを保存
                // 実際の実装ではイベントからテキストを再構築する必要がある
                if !title.is_empty() {
                    content = md_str.to_string();
                }
            },
            _ => {}
        }
    }
    
    // タイトルが見つからない場合は元のテキストをコンテンツとして扱う
    if title.is_empty() {
        content = md_str.to_string();
        title = "Untitled Document".to_string();
    } else {
        // タイトルの部分をコンテンツから削除（簡易的な実装）
        if let Some(pos) = content.find(&title) {
            if let Some(end_pos) = content[pos..].find('\n') {
                content = content[pos + end_pos + 1..].to_string();
            }
        }
    }
    
    // YAMLの構築
    let yaml = format!("title: {}\ncontent: |\n{}", title, indent_content(&content));
    
    yaml
}

/// YAMLをMarkdownテキストに変換する
///
/// # 引数
/// * `yaml_str` - 変換元のYAML文字列
///
/// # 戻り値
/// * 成功時: Markdown形式の文字列
/// * 失敗時: エラー情報を含むJSON文字列
///
/// # 動作概要
/// 1. YAMLをパースして構造データに変換
/// 2. タイトルとコンテンツを抽出
/// 3. Markdownフォーマットに整形して返す
pub fn yaml_to_md(yaml_str: &str) -> String {
    match serde_yaml::from_str::<Value>(yaml_str) {
        Ok(value) => {
            let mut md = String::new();
            
            // タイトルの抽出
            if let Some(title) = value.get("title").and_then(|t| t.as_str()) {
                md.push_str(&format!("# {}\n\n", title));
            }
            
            // コンテンツの抽出
            if let Some(content) = value.get("content").and_then(|c| c.as_str()) {
                md.push_str(content);
                if !content.ends_with('\n') {
                    md.push('\n');
                }
            }
            
            // 他のフィールドは必要に応じて処理（この例では省略）
            
            md
        },
        Err(e) => {
            let result = ValidationResult::single_error(
                ErrorInfo::new(0, format!("YAML parse error: {}", e), "")
            );
            result.to_json()
        }
    }
}

/// テキストコンテンツをYAML複数行文字列用にインデントする
fn indent_content(content: &str) -> String {
    content
        .lines()
        .map(|line| format!("  {}", line))
        .collect::<Vec<String>>()
        .join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_md_to_yaml_basic() {
        let md = "# Test Title\n\nThis is a test content.";
        let yaml = md_to_yaml(md);
        
        assert!(yaml.contains("title: Test Title"));
        assert!(yaml.contains("content: |"));
        assert!(yaml.contains("  This is a test content."));
    }
    
    #[test]
    fn test_yaml_to_md_basic() {
        let yaml = "title: Test Title\ncontent: |\n  This is a test content.\n  With multiple lines.";
        let md = yaml_to_md(yaml);
        
        assert!(md.contains("# Test Title"));
        assert!(md.contains("This is a test content."));
        assert!(md.contains("With multiple lines."));
    }
    
    #[test]
    fn test_md_roundtrip() {
        // Markdown -> YAML -> Markdown の変換で情報が保持されるかをテスト
        let original_md = "# Roundtrip Test\n\nThis is a test for roundtrip conversion.";
        let yaml = md_to_yaml(original_md);
        let roundtrip_md = yaml_to_md(&yaml);
        
        assert_eq!(original_md, roundtrip_md.trim());
    }
}
```

### 2. `lib.rs` の更新

次に、`lib.rs` ファイルを更新して新しいモジュールをインポートし、WebAssemblyエクスポート用の関数を追加します：

```rust
// 既存のインポートに追加
mod md_transform;

// 既存のexportに追加
pub use md_transform::{md_to_yaml, yaml_to_md};

// WebAssembly エクスポート関数を追加
/// Markdown文字列をYAML文字列に変換する
///
/// # 引数
/// * `md_str` - Markdown形式の文字列
///
/// # 戻り値
/// * 成功時: YAML形式の文字列
/// * 失敗時: エラー情報を含むJSON文字列
#[wasm_bindgen]
pub fn md_to_yaml(md_str: &str) -> String {
    md_transform::md_to_yaml(md_str)
}

/// YAML文字列をMarkdown文字列に変換する
///
/// # 引数
/// * `yaml_str` - YAML形式の文字列
///
/// # 戻り値
/// * 成功時: Markdown形式の文字列
/// * 失敗時: エラー情報を含むJSON文字列
#[wasm_bindgen]
pub fn yaml_to_md(yaml_str: &str) -> String {
    md_transform::yaml_to_md(yaml_str)
}
```

### 3. Cargo.toml の更新

`packages/core-wasm/Cargo.toml` に必要な依存関係を追加します：

```toml
[dependencies]
pulldown-cmark = "0.9.2"
# 他の既存の依存関係...
```

### 4. WASMをビルドする

変更を適用し、WebAssemblyモジュールを再ビルドします：

```bash
cd packages/core-wasm
./build.sh
```

### 5. TypeScriptインターフェースの更新

`apps/web/src/types/core-wasm.d.ts` ファイルを更新し、新しい関数を追加します：

```typescript
declare module 'core-wasm' {
  export function validate_yaml(yaml: string, schema: string): string;
  export function parse_yaml(yaml: string): string;
  export function stringify_yaml(json: string): string;
  export function apply_patch(yaml: string, patch: string): string;
  // 新しい関数を追加
  export function md_to_yaml(md: string): string;
  export function yaml_to_md(yaml: string): string;
  export function version(): string;
}
```

### 6. `useYamlCore.ts` フックの作成

Markdownとの相互変換機能を提供するフックを作成します。`apps/web/src/hooks/useYamlCore.ts` というファイルを作成します：

```typescript
import { useState, useEffect, useCallback } from 'react';
import { debounce } from 'lodash-es';

// モックインタフェースでWASMモジュールを定義
interface CoreWasmType {
  validate_yaml: (yaml: string, schema: string) => string;
  parse_yaml: (yaml: string) => string;
  stringify_yaml: (json: string) => string;
  apply_patch: (yaml: string, patch: string) => string;
  md_to_yaml: (md: string) => string;
  yaml_to_md: (yaml: string) => string;
  version: () => string;
}

// 実際の使用時にはランタイムでモジュールをロード
let CoreWasm: CoreWasmType;

// 変換結果の型定義
export interface ConversionResult {
  success: boolean;
  content: string;
  error?: string;
}

/**
 * YAML/Markdownの相互変換機能を提供するカスタムフック
 * 
 * @description
 * WASMコアモジュールを利用して、Markdown<->YAML間の変換機能を提供します。
 * 初期化状態の管理や変換処理のデバウンスを内部で行います。
 * 
 * @returns {{
 *   isInitialized: boolean;
 *   mdToYaml: (md: string) => Promise<ConversionResult>;
 *   yamlToMd: (yaml: string) => Promise<ConversionResult>;
 * }}
 */
export function useYamlCore() {
  // WASM初期化状態
  const [isInitialized, setIsInitialized] = useState(false);
  
  // WASM初期化
  useEffect(() => {
    const loadWasm = async () => {
      try {
        // 動的インポート
        const wasmModule = await import('core-wasm');
        CoreWasm = wasmModule;
        
        // WASMのバージョン確認
        const version = CoreWasm.version();
        console.log(`Core WASM loaded, version: ${version}`);
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to initialize WASM module:', error);
        setIsInitialized(false);
      }
    };
    
    loadWasm();
  }, []);
  
  // Markdown -> YAML 変換関数
  const mdToYaml = useCallback(
    debounce(async (md: string): Promise<ConversionResult> => {
      if (!isInitialized || !CoreWasm) {
        return { 
          success: false, 
          content: '', 
          error: 'WASM not initialized' 
        };
      }
      
      if (!md.trim()) {
        return { success: true, content: '' };
      }
      
      try {
        const result = CoreWasm.md_to_yaml(md);
        
        // エラーチェック（JSONで返ってくる場合はエラー）
        if (result.includes('"success":false')) {
          const errorObj = JSON.parse(result);
          return {
            success: false,
            content: '',
            error: errorObj.errors?.[0]?.message || 'Unknown error'
          };
        }
        
        return { success: true, content: result };
      } catch (error) {
        console.error('MD to YAML conversion error:', error);
        return {
          success: false,
          content: '',
          error: `変換エラー: ${error}`
        };
      }
    }, 30), // 30msのデバウンス
    [isInitialized]
  );
  
  // YAML -> Markdown 変換関数
  const yamlToMd = useCallback(
    debounce(async (yaml: string): Promise<ConversionResult> => {
      if (!isInitialized || !CoreWasm) {
        return { 
          success: false, 
          content: '', 
          error: 'WASM not initialized' 
        };
      }
      
      if (!yaml.trim()) {
        return { success: true, content: '' };
      }
      
      try {
        const result = CoreWasm.yaml_to_md(yaml);
        
        // エラーチェック
        if (result.includes('"success":false')) {
          const errorObj = JSON.parse(result);
          return {
            success: false,
            content: '',
            error: errorObj.errors?.[0]?.message || 'Unknown error'
          };
        }
        
        return { success: true, content: result };
      } catch (error) {
        console.error('YAML to MD conversion error:', error);
        return {
          success: false,
          content: '',
          error: `変換エラー: ${error}`
        };
      }
    }, 30), // 30msのデバウンス
    [isInitialized]
  );
  
  return {
    isInitialized,
    mdToYaml,
    yamlToMd
  };
}

export default useYamlCore;
```

### 7. テストの実行

実装が完了したら、テストを実行してすべてのテストが通ることを確認します：

```bash
# core-wasmディレクトリでRustのテストを実行
cd packages/core-wasm
cargo test

# md_roundtripテストを個別に実行
cargo test md_roundtrip

# TypeScriptの型チェックを実行
cd ../..
pnpm typecheck
```

## 実装の注意点

1. **Markdown解析の詳細度**: 上記サンプルではシンプルな実装を示していますが、実際の実装ではより複雑なMarkdown構造（テーブル、リスト、コードブロックなど）の扱いが必要になる場合があります。

2. **パフォーマンス考慮**: WebAssemblyの利点を活かすため、変換処理は効率的に実装し、サブミリ秒レベルの応答を目指します。

3. **エラーハンドリング**: 様々な入力パターンに対応するためのエラーハンドリングを丁寧に実装します。

4. **テストカバレッジ**: 様々なパターンのMarkdown入力やYAML構造に対するテストを充実させます。

## 次のステップ

フェーズ6aが完了したら、次のフェーズ6bで差分とパッチの実装に進みます。この変換機能の実装は、フェーズ7以降のLive Previewやバリデーション機能の基盤となります。