# 実装手順: フェーズ6b - 差分 & パッチ

## 概要

フェーズ6bでは、YAMLデータの差分機能およびパッチ適用機能を強化し、タブ切替時の競合検知と警告UIを実装します。これにより、異なるタブ間で編集した内容に競合がある場合にユーザーに通知し、適切な選択を促すことができるようになります。

## 達成基準

- `yaml_diff` / `apply_patch` 機能の強化実装（Rust）
- タブ切替時の競合検知メカニズムの実装
- 編集競合時に警告ダイアログを表示する機能の実装

## 必要な依存関係

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"
serde_json = "1.0"
json-patch = "0.3.0"  # RFC 6902 JSON Patch実装
wasm-bindgen = "0.2"
```

## 実装ステップ

### 1. `diff.rs` モジュールの強化

- [ ] `packages/core-wasm/src/diff.rs` ファイルを作成または更新して、YAML差分検知機能を実装します：

```rust
//! diff.rs
//!
//! YAML文書間の差分検出と適用を行うモジュール。
//! - 2つのYAML文書の差分をJSON Patchとして生成
//! - JSON Patchを既存のYAML文書に適用
//! - 競合検出機能の提供

use serde_json::{Value, json};
use json_patch::{Patch, PatchOperation, AddOperation, RemoveOperation, ReplaceOperation, MoveOperation, CopyOperation, TestOperation};
use crate::error::{ErrorInfo, ValidationResult};

/// 2つのYAML文字列間の差分をJSON Patch形式で返す
///
/// # 引数
/// * `base_yaml` - ベースとなるYAML文字列
/// * `edited_yaml` - 編集後のYAML文字列
///
/// # 戻り値
/// * 成功時: JSON Patch形式の文字列
/// * 失敗時: エラー情報を含むJSON文字列
///
/// # 動作概要
/// 1. 両方のYAMLをJSONに変換
/// 2. JSONの差分をPatchとして抽出
/// 3. Patchを文字列化して返す
pub fn yaml_diff(base_yaml: &str, edited_yaml: &str) -> String {
    // YAMLをJSONに変換
    let base_value = match serde_yaml::from_str::<Value>(base_yaml) {
        Ok(v) => v,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Base YAML parse error: {}", e), "")
            ).to_json();
        }
    };
    
    let edited_value = match serde_yaml::from_str::<Value>(edited_yaml) {
        Ok(v) => v,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Edited YAML parse error: {}", e), "")
            ).to_json();
        }
    };
    
    // JSONの差分を計算
    let patch = match json_patch::diff(&base_value, &edited_value) {
        Ok(p) => p,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Diff calculation error: {}", e), "")
            ).to_json();
        }
    };
    
    // Patchを文字列化
    match serde_json::to_string(&patch) {
        Ok(p) => p,
        Err(e) => {
            ValidationResult::single_error(
                ErrorInfo::new(0, format!("Patch serialization error: {}", e), "")
            ).to_json()
        }
    }
}

/// JSON Patchを既存のYAML文字列に適用して新しいYAML文字列を返す
///
/// # 引数
/// * `yaml` - 適用先のYAML文字列
/// * `patch_str` - 適用するJSON Patch文字列
///
/// # 戻り値
/// * 成功時: パッチ適用後のYAML文字列
/// * 失敗時: エラー情報を含むJSON文字列
///
/// # 動作概要
/// 1. YAMLをJSONに変換
/// 2. パッチをJSONに変換
/// 3. パッチをJSONに適用
/// 4. 結果をYAMLに変換して返す
pub fn apply_patch(yaml: &str, patch_str: &str) -> String {
    // YAMLをJSONに変換
    let mut value = match serde_yaml::from_str::<Value>(yaml) {
        Ok(v) => v,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("YAML parse error: {}", e), "")
            ).to_json();
        }
    };
    
    // パッチをデシリアライズ
    let patch: Patch = match serde_json::from_str(patch_str) {
        Ok(p) => p,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Patch parse error: {}", e), "")
            ).to_json();
        }
    };
    
    // パッチを適用
    if let Err(e) = json_patch::patch(&mut value, &patch) {
        return ValidationResult::single_error(
            ErrorInfo::new(0, format!("Patch application error: {}", e), "")
        ).to_json();
    }
    
    // JSONをYAMLに変換
    match serde_yaml::to_string(&value) {
        Ok(y) => y,
        Err(e) => {
            ValidationResult::single_error(
                ErrorInfo::new(0, format!("YAML conversion error: {}", e), "")
            ).to_json()
        }
    }
}

/// 2つのYAML文字列間に競合があるかを判断する
///
/// # 引数
/// * `base_yaml` - ベースとなるYAML文字列
/// * `tab1_yaml` - タブ1のYAML文字列
/// * `tab2_yaml` - タブ2のYAML文字列
///
/// # 戻り値
/// * 競合がある場合: 競合情報を含むJSON文字列
/// * 競合がない場合: '{"conflicts": false}' のJSON文字列
///
/// # 動作概要
/// 1. 両方のタブのYAMLとベースYAMLの差分をそれぞれ計算
/// 2. 両方の差分が同じフィールドを変更している場合は競合と判断
pub fn detect_conflicts(base_yaml: &str, tab1_yaml: &str, tab2_yaml: &str) -> String {
    // base -> tab1の差分
    let patch1_result = yaml_diff(base_yaml, tab1_yaml);
    if patch1_result.contains("\"success\":false") {
        return patch1_result;
    }
    
    // base -> tab2の差分
    let patch2_result = yaml_diff(base_yaml, tab2_yaml);
    if patch2_result.contains("\"success\":false") {
        return patch2_result;
    }
    
    // パッチをデシリアライズ
    let patch1: Patch = match serde_json::from_str(&patch1_result) {
        Ok(p) => p,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Patch1 parse error: {}", e), "")
            ).to_json();
        }
    };
    
    let patch2: Patch = match serde_json::from_str(&patch2_result) {
        Ok(p) => p,
        Err(e) => {
            return ValidationResult::single_error(
                ErrorInfo::new(0, format!("Patch2 parse error: {}", e), "")
            ).to_json();
        }
    };
    
    // 競合検出ロジック（単純な例）：
    // 同じパスに対する変更があれば競合と判断
    let mut conflicts = Vec::new();
    
    for op1 in &patch1.0 {
        let path1 = op1.path();
        
        for op2 in &patch2.0 {
            let path2 = op2.path();
            
            if path1 == path2 {
                conflicts.push(json!({
                    "path": path1,
                    "tab1_operation": format!("{:?}", op1),
                    "tab2_operation": format!("{:?}", op2)
                }));
            }
        }
    }
    
    if conflicts.is_empty() {
        r#"{"conflicts": false}"#.to_string()
    } else {
        match serde_json::to_string(&json!({
            "conflicts": true,
            "details": conflicts
        })) {
            Ok(result) => result,
            Err(e) => ValidationResult::single_error(
                ErrorInfo::new(0, format!("Conflict serialization error: {}", e), "")
            ).to_json()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_yaml_diff_basic() {
        let base = "title: Original\ncontent: Hello";
        let edited = "title: Modified\ncontent: Hello";
        
        let patch_str = yaml_diff(base, edited);
        let patch: Patch = serde_json::from_str(&patch_str).unwrap();
        
        assert_eq!(patch.0.len(), 1);
        match &patch.0[0] {
            PatchOperation::Replace(op) => {
                assert_eq!(op.path.to_string(), "/title");
                assert_eq!(op.value, "Modified");
            },
            _ => panic!("Expected Replace operation"),
        }
    }
    
    #[test]
    fn test_apply_patch_basic() {
        let yaml = "title: Original\ncontent: Hello";
        let patch = r#"[{"op":"replace","path":"/title","value":"Modified"}]"#;
        
        let result = apply_patch(yaml, patch);
        
        assert!(result.contains("title: Modified"));
        assert!(result.contains("content: Hello"));
    }
    
    #[test]
    fn test_detect_conflicts() {
        let base = "title: Original\ncontent: Hello\ntags: [a, b]";
        let tab1 = "title: Changed in Tab1\ncontent: Hello\ntags: [a, b]";
        let tab2 = "title: Changed in Tab2\ncontent: Hello\ntags: [a, b]";
        
        let result = detect_conflicts(base, tab1, tab2);
        
        assert!(result.contains("\"conflicts\":true"));
        assert!(result.contains("\"/title\""));
    }
    
    #[test]
    fn test_no_conflicts() {
        let base = "title: Original\ncontent: Hello\ntags: [a, b]";
        let tab1 = "title: Changed\ncontent: Hello\ntags: [a, b]";
        let tab2 = "title: Original\ncontent: Modified\ntags: [a, b]";
        
        let result = detect_conflicts(base, tab1, tab2);
        
        assert!(result.contains("\"conflicts\":false"));
    }
}
```

### 2. `lib.rs` の更新

- [ ] `lib.rs` ファイルを更新して新しい関数をエクスポートします：

```rust
// 既存のインポートに追加
mod diff;

// 既存のexportに追加
pub use diff::{yaml_diff, apply_patch, detect_conflicts};

// WebAssembly エクスポート関数を追加
#[wasm_bindgen]
pub fn yaml_diff(base_yaml: &str, edited_yaml: &str) -> String {
    diff::yaml_diff(base_yaml, edited_yaml)
}

#[wasm_bindgen]
pub fn apply_patch(yaml: &str, patch_str: &str) -> String {
    diff::apply_patch(yaml, patch_str)
}

#[wasm_bindgen]
pub fn detect_conflicts(base_yaml: &str, tab1_yaml: &str, tab2_yaml: &str) -> String {
    diff::detect_conflicts(base_yaml, tab1_yaml, tab2_yaml)
}
```

### 3. Cargo.toml の更新

- [ ] `packages/core-wasm/Cargo.toml` に必要な依存関係を追加します：

```toml
[dependencies]
json-patch = "0.3.0"
# 他の既存の依存関係...
```

### 4. TypeScriptインターフェースの更新

- [ ] `apps/web/src/types/core-wasm.d.ts` ファイルを更新して新しい関数を追加します：

```typescript
declare module 'core-wasm' {
  export function validate_yaml(yaml: string, schema: string): string;
  export function parse_yaml(yaml: string): string;
  export function stringify_yaml(json: string): string;
  export function apply_patch(yaml: string, patch: string): string;
  export function md_to_yaml(md: string): string;
  export function yaml_to_md(yaml: string): string;
  // 新しい関数を追加
  export function yaml_diff(base_yaml: string, edited_yaml: string): string;
  export function detect_conflicts(base_yaml: string, tab1_yaml: string, tab2_yaml: string): string;
  export function version(): string;
}
```

### 5. `useYamlDiff.ts` フックの作成

- [ ] `apps/web/src/hooks/useYamlDiff.ts` というファイルを作成します：

```typescript
import { useState, useEffect, useCallback } from 'react';
import { debounce } from 'lodash-es';

// WASMコアモジュールの型定義
interface CoreWasmType {
  validate_yaml: (yaml: string, schema: string) => string;
  yaml_diff: (base_yaml: string, edited_yaml: string) => string;
  apply_patch: (yaml: string, patch: string) => string;
  detect_conflicts: (base_yaml: string, tab1_yaml: string, tab2_yaml: string) => string;
  version: () => string;
}

// 実際の使用時にはランタイムでモジュールをロード
let CoreWasm: CoreWasmType;

// 差分結果の型定義
export interface DiffResult {
  success: boolean;
  patch?: string;
  error?: string;
}

// 競合検出結果の型定義
export interface ConflictResult {
  conflicts: boolean;
  details?: Array<{
    path: string;
    tab1_operation: string;
    tab2_operation: string;
  }>;
  error?: string;
}

/**
 * YAML差分計算と競合検出機能を提供するカスタムフック
 * 
 * @description
 * WASMコアモジュールを利用して、YAML間の差分計算や競合検出機能を提供します。
 * タブ切替時の競合検知や、差分パッチの適用処理に使用します。
 * 
 * @returns {{
 *   isInitialized: boolean;
 *   calculateDiff: (baseYaml: string, editedYaml: string) => Promise<DiffResult>;
 *   applyPatch: (yaml: string, patch: string) => Promise<string>;
 *   detectConflicts: (baseYaml: string, tab1Yaml: string, tab2Yaml: string) => Promise<ConflictResult>;
 * }}
 */
export function useYamlDiff() {
  // WASM初期化状態
  const [isInitialized, setIsInitialized] = useState(false);
  
  // WASM初期化
  useEffect(() => {
    const loadWasm = async () => {
      try {
        // 動的インポート
        const wasmModule = await import('core-wasm');
        CoreWasm = wasmModule as unknown as CoreWasmType;
        
        // WASMのバージョン確認
        const version = CoreWasm.version();
        console.log(`Core WASM loaded in useYamlDiff, version: ${version}`);
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to initialize WASM module:', error);
        setIsInitialized(false);
      }
    };
    
    loadWasm();
  }, []);
  
  // YAML間の差分を計算する関数
  const calculateDiff = useCallback(
    async (baseYaml: string, editedYaml: string): Promise<DiffResult> => {
      if (!isInitialized || !CoreWasm) {
        return { 
          success: false, 
          error: 'WASM not initialized' 
        };
      }
      
      try {
        const result = CoreWasm.yaml_diff(baseYaml, editedYaml);
        
        // エラーチェック（JSONで返ってくる場合はエラー）
        if (result.includes('"success":false')) {
          const errorObj = JSON.parse(result);
          return {
            success: false,
            error: errorObj.errors?.[0]?.message || 'Unknown error'
          };
        }
        
        return { success: true, patch: result };
      } catch (error) {
        console.error('YAML diff calculation error:', error);
        return {
          success: false,
          error: `差分計算エラー: ${error}`
        };
      }
    },
    [isInitialized]
  );
  
  // パッチを適用する関数
  const applyPatch = useCallback(
    async (yaml: string, patch: string): Promise<string> => {
      if (!isInitialized || !CoreWasm) {
        throw new Error('WASM not initialized');
      }
      
      const result = CoreWasm.apply_patch(yaml, patch);
      
      // エラーチェック
      if (result.includes('"success":false')) {
        const errorObj = JSON.parse(result);
        throw new Error(errorObj.errors?.[0]?.message || 'Unknown patch error');
      }
      
      return result;
    },
    [isInitialized]
  );
  
  // 競合を検出する関数
  const detectConflicts = useCallback(
    async (baseYaml: string, tab1Yaml: string, tab2Yaml: string): Promise<ConflictResult> => {
      if (!isInitialized || !CoreWasm) {
        return { 
          conflicts: false, 
          error: 'WASM not initialized' 
        };
      }
      
      try {
        const result = CoreWasm.detect_conflicts(baseYaml, tab1Yaml, tab2Yaml);
        
        // エラーチェック
        if (result.includes('"success":false')) {
          const errorObj = JSON.parse(result);
          return {
            conflicts: false,
            error: errorObj.errors?.[0]?.message || 'Unknown conflict detection error'
          };
        }
        
        return JSON.parse(result) as ConflictResult;
      } catch (error) {
        console.error('Conflict detection error:', error);
        return {
          conflicts: false,
          error: `競合検出エラー: ${error}`
        };
      }
    },
    [isInitialized]
  );
  
  return {
    isInitialized,
    calculateDiff,
    applyPatch,
    detectConflicts
  };
}

export default useYamlDiff;
```

### 6. `ConflictDialog` コンポーネントの作成

- [ ] `apps/web/src/components/ConflictDialog.tsx` ファイルを作成して競合ダイアログを実装します：

```typescript
import React from 'react';

export interface ConflictDialogProps {
  isOpen: boolean;
  conflicts: Array<{
    path: string;
    tab1_operation: string;
    tab2_operation: string;
  }>;
  onResolve: (useTab1: boolean) => void;
  onCancel: () => void;
  tab1Name: string;
  tab2Name: string;
}

/**
 * 編集競合ダイアログコンポーネント
 * 
 * @description
 * 異なるタブで同じフィールドが編集された場合に
 * どちらの編集内容を優先するかをユーザーに選択させるダイアログ
 */
const ConflictDialog: React.FC<ConflictDialogProps> = ({
  isOpen,
  conflicts,
  onResolve,
  onCancel,
  tab1Name,
  tab2Name
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="bg-white rounded-lg p-6 max-w-lg w-full shadow-xl">
        <h2 className="text-xl font-bold text-red-600 mb-4">編集の競合が検出されました</h2>
        
        <p className="mb-4">
          {tab1Name}タブと{tab2Name}タブの間で同じフィールドが編集されています。
          どちらの変更を保持しますか？
        </p>
        
        <div className="mb-4 max-h-60 overflow-y-auto">
          <h3 className="font-semibold mb-2">競合箇所:</h3>
          <ul className="list-disc pl-5 text-sm">
            {conflicts.map((conflict, index) => (
              <li key={index} className="mb-2">
                <span className="font-mono text-sm bg-gray-100 px-1 rounded">{conflict.path}</span>
                <div className="grid grid-cols-2 gap-2 mt-1">
                  <div className="text-xs p-2 bg-blue-50 rounded">
                    <div className="font-semibold mb-1">{tab1Name}:</div>
                    {conflict.tab1_operation}
                  </div>
                  <div className="text-xs p-2 bg-green-50 rounded">
                    <div className="font-semibold mb-1">{tab2Name}:</div>
                    {conflict.tab2_operation}
                  </div>
                </div>
              </li>
            ))}
          </ul>
        </div>
        
        <div className="flex justify-end gap-3">
          <button
            onClick={onCancel}
            className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          >
            キャンセル
          </button>
          <button
            onClick={() => onResolve(true)}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            {tab1Name}の変更を使用
          </button>
          <button
            onClick={() => onResolve(false)}
            className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
          >
            {tab2Name}の変更を使用
          </button>
        </div>
      </div>
    </div>
  );
};

export default ConflictDialog;
```

### 7. タブ機能を含む `EditorTabs` コンポーネントの作成

- [ ] `apps/web/src/components/EditorTabs.tsx` ファイルを作成します：

```typescript
import React, { useState, useEffect, useRef } from 'react';
import YamlEditor from './YamlEditor';
import ConflictDialog from './ConflictDialog';
import useYamlDiff from '../hooks/useYamlDiff';
import useYamlCore from '../hooks/useYamlCore';
import useLogger from '../hooks/useLogger';

export type TabType = 'yaml' | 'markdown' | 'schema';

interface EditorTabsProps {
  yamlContent: string;
  onYamlChange: (yaml: string) => void;
  markdownContent: string;
  schemaContent: string;
  onSchemaChange?: (schema: string) => void;
  editorRef: React.RefObject<any>;
}

/**
 * エディタタブコンポーネント
 * 
 * @description
 * YAML、Markdown、Schemaの3つのタブを切り替え可能なエディタ。
 * タブ間の切り替え時に競合検出を行い、必要に応じて警告ダイアログを表示する。
 */
const EditorTabs: React.FC<EditorTabsProps> = ({
  yamlContent,
  onYamlChange,
  markdownContent,
  schemaContent,
  onSchemaChange,
  editorRef
}) => {
  // 現在のタブ
  const [activeTab, setActiveTab] = useState<TabType>('yaml');
  // 前回のタブ
  const [previousTab, setPreviousTab] = useState<TabType>('yaml');
  // 各タブでの最後の編集内容
  const [lastYamlContent, setLastYamlContent] = useState(yamlContent);
  const [lastMarkdownContent, setLastMarkdownContent] = useState(markdownContent);
  const [lastSchemaContent, setLastSchemaContent] = useState(schemaContent);
  // 競合ダイアログの状態
  const [showConflictDialog, setShowConflictDialog] = useState(false);
  const [conflicts, setConflicts] = useState<Array<any>>([]);
  // 切り替え先のタブ（競合時に一時保存）
  const pendingTabChange = useRef<TabType | null>(null);
  
  // カスタムフック
  const { isInitialized: isDiffInitialized, detectConflicts } = useYamlDiff();
  const { isInitialized: isCoreInitialized, mdToYaml, yamlToMd } = useYamlCore();
  const { log } = useLogger();
  
  // Markdownの編集内容
  const [editedMarkdown, setEditedMarkdown] = useState(markdownContent);
  // Schemaの編集内容
  const [editedSchema, setEditedSchema] = useState(schemaContent);
  
  // 親からの内容変更を反映
  useEffect(() => {
    if (activeTab !== 'yaml') return;
    setLastYamlContent(yamlContent);
  }, [yamlContent, activeTab]);
  
  useEffect(() => {
    if (activeTab !== 'markdown') return;
    setEditedMarkdown(markdownContent);
    setLastMarkdownContent(markdownContent);
  }, [markdownContent, activeTab]);
  
  useEffect(() => {
    if (activeTab !== 'schema') return;
    setEditedSchema(schemaContent);
    setLastSchemaContent(schemaContent);
  }, [schemaContent, activeTab]);
  
  // タブ切り替えハンドラ
  const handleTabChange = async (newTab: TabType) => {
    if (newTab === activeTab) return;
    
    // 現在のタブの内容を保存
    let currentContent = '';
    let baseContent = '';
    
    switch (activeTab) {
      case 'yaml':
        currentContent = yamlContent;
        setLastYamlContent(yamlContent);
        break;
      case 'markdown':
        currentContent = editedMarkdown;
        setLastMarkdownContent(editedMarkdown);
        break;
      case 'schema':
        currentContent = editedSchema;
        setLastSchemaContent(editedSchema);
        break;
    }
    
    // 切り替え先の前回保存内容
    switch (newTab) {
      case 'yaml':
        baseContent = lastYamlContent;
        break;
      case 'markdown':
        baseContent = lastMarkdownContent;
        break;
      case 'schema':
        baseContent = lastSchemaContent;
        break;
    }
    
    // YAMLとMarkdownの間の切り替えで、内容を変換して競合チェック
    if ((activeTab === 'yaml' && newTab === 'markdown') || 
        (activeTab === 'markdown' && newTab === 'yaml')) {
      
      if (!isCoreInitialized || !isDiffInitialized) {
        // 初期化されていない場合は単純に切り替え
        setPreviousTab(activeTab);
        setActiveTab(newTab);
        return;
      }
      
      try {
        let tab1Content = '';
        let tab2Content = '';
        
        // 現在のタブの内容をYAMLに変換
        if (activeTab === 'yaml') {
          tab1Content = yamlContent;
        } else {
          const result = await mdToYaml(editedMarkdown);
          if (result.success) {
            tab1Content = result.content;
          } else {
            // 変換エラーの場合はダイアログなしで切り替え
            log('warn', 'md_to_yaml_error', {
              error: result.error
            });
            setPreviousTab(activeTab);
            setActiveTab(newTab);
            return;
          }
        }
        
        // 切り替え先タブの前回の内容をYAMLに変換
        if (newTab === 'yaml') {
          tab2Content = lastYamlContent;
        } else {
          const result = await mdToYaml(lastMarkdownContent);
          if (result.success) {
            tab2Content = result.content;
          } else {
            // 変換エラーの場合はダイアログなしで切り替え
            log('warn', 'md_to_yaml_error', {
              error: result.error
            });
            setPreviousTab(activeTab);
            setActiveTab(newTab);
            return;
          }
        }
        
        // 共通のベース（最後に同期した状態）
        const baseYaml = yamlContent; // これは単純化のため、実際には最後に同期した状態を使う
        
        // 競合検出
        const conflictResult = await detectConflicts(baseYaml, tab1Content, tab2Content);
        
        if (conflictResult.conflicts && conflictResult.details && conflictResult.details.length > 0) {
          // 競合がある場合、ダイアログを表示
          setConflicts(conflictResult.details);
          setShowConflictDialog(true);
          pendingTabChange.current = newTab;
          
          log('info', 'tab_switch_conflict_detected', {
            fromTab: activeTab,
            toTab: newTab,
            conflictPaths: conflictResult.details.map(c => c.path)
          });
          
          return;
        }
      } catch (error) {
        console.error('Error during tab change conflict detection:', error);
        log('error', 'tab_switch_conflict_error', {
          error: String(error)
        });
      }
    }
    
    // 競合がないか、他のタブへの切り替えの場合
    log('info', 'tab_switch', {
      fromTab: activeTab,
      toTab: newTab
    });
    
    setPreviousTab(activeTab);
    setActiveTab(newTab);
  };
  
  // Markdown編集ハンドラ
  const handleMarkdownChange = (newMarkdown: string) => {
    setEditedMarkdown(newMarkdown);
    
    // debounceされたYAML変換（useYamlCore内で実装済み）
    if (isCoreInitialized) {
      mdToYaml(newMarkdown).then(result => {
        if (result.success) {
          onYamlChange(result.content);
        }
      });
    }
  };
  
  // Schema編集ハンドラ
  const handleSchemaChange = (newSchema: string) => {
    setEditedSchema(newSchema);
    if (onSchemaChange) {
      onSchemaChange(newSchema);
    }
  };
  
  // 競合解決ハンドラ
  const handleConflictResolve = (useCurrentTab: boolean) => {
    if (pendingTabChange.current === null) return;
    
    log('info', 'conflict_resolved', {
      resolution: useCurrentTab ? 'keep_current' : 'use_target',
      fromTab: activeTab,
      toTab: pendingTabChange.current
    });
    
    if (useCurrentTab) {
      // 現在のタブの内容を保持し、切り替え先タブの内容を更新
      if (activeTab === 'yaml' && pendingTabChange.current === 'markdown') {
        // YAMLの内容をMarkdownに変換して設定
        yamlToMd(yamlContent).then(result => {
          if (result.success) {
            setEditedMarkdown(result.content);
            setLastMarkdownContent(result.content);
          }
        });
      } else if (activeTab === 'markdown' && pendingTabChange.current === 'yaml') {
        // すでにonYamlChangeでYAMLは更新されているはず
        setLastYamlContent(yamlContent);
      }
    } else {
      // 切り替え先タブの内容を使用
      if (activeTab === 'yaml' && pendingTabChange.current === 'markdown') {
        // 何もしない（切り替え後にMarkdownの内容を編集）
      } else if (activeTab === 'markdown' && pendingTabChange.current === 'yaml') {
        // YAMLの内容を元に戻す
        onYamlChange(lastYamlContent);
        yamlToMd(lastYamlContent).then(result => {
          if (result.success) {
            setEditedMarkdown(result.content);
          }
        });
      }
    }
    
    // ダイアログを閉じてタブを切り替え
    setShowConflictDialog(false);
    setActiveTab(pendingTabChange.current);
    setPreviousTab(activeTab);
    pendingTabChange.current = null;
  };
  
  // 競合キャンセルハンドラ
  const handleConflictCancel = () => {
    setShowConflictDialog(false);
    pendingTabChange.current = null;
    
    log('info', 'conflict_cancelled', {
      fromTab: activeTab,
      toTab: pendingTabChange.current
    });
  };
  
  return (
    <div className="h-full flex flex-col">
      <div className="flex border-b mb-2">
        <button
          onClick={() => handleTabChange('yaml')}
          className={`px-4 py-2 border-b-2 ${
            activeTab === 'yaml'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent hover:text-blue-500'
          }`}
        >
          YAML
        </button>
        <button
          onClick={() => handleTabChange('markdown')}
          className={`px-4 py-2 border-b-2 ${
            activeTab === 'markdown'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent hover:text-blue-500'
          }`}
        >
          Markdown
        </button>
        <button
          onClick={() => handleTabChange('schema')}
          className={`px-4 py-2 border-b-2 ${
            activeTab === 'schema'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent hover:text-blue-500'
          }`}
        >
          Schema
        </button>
      </div>
      
      <div className="flex-1 relative">
        {activeTab === 'yaml' && (
          <YamlEditor
            value={yamlContent}
            onChange={onYamlChange}
            className="h-full"
            editorRef={editorRef}
          />
        )}
        
        {activeTab === 'markdown' && (
          <YamlEditor
            value={editedMarkdown}
            onChange={handleMarkdownChange}
            className="h-full"
            language="markdown"
          />
        )}
        
        {activeTab === 'schema' && (
          <YamlEditor
            value={editedSchema}
            onChange={handleSchemaChange}
            className="h-full"
            language="yaml"
          />
        )}
      </div>
      
      <ConflictDialog
        isOpen={showConflictDialog}
        conflicts={conflicts}
        onResolve={handleConflictResolve}
        onCancel={handleConflictCancel}
        tab1Name={activeTab}
        tab2Name={pendingTabChange.current || ''}
      />
    </div>
  );
};

export default EditorTabs;
```

### 8. App.tsx の更新

- [ ] `apps/web/src/App.tsx` ファイルを更新してタブエディタを統合します：

```typescript
// App.tsx内のYamlEditorコンポーネントの部分を
// EditorTabsコンポーネントに置き換える

import EditorTabs from './components/EditorTabs';

// 既存のコードに以下を追加
const [schemaContent, setSchemaContent] = useState<string>(''); // スキーマ内容

// スキーマを読み込む
useEffect(() => {
  const loadSchema = async () => {
    try {
      const response = await fetch(schemaPath);
      if (response.ok) {
        const content = await response.text();
        setSchemaContent(content);
      }
    } catch (error) {
      console.error('Error loading schema:', error);
    }
  };
  
  loadSchema();
}, []);

// YAMLエディタの部分を置き換え
{(viewMode === 'editor' || viewMode === 'split') && (
  <div className="relative h-full" style={{
    width: viewMode === 'split' ? 'auto' : '100%'
  }}>
    <EditorTabs
      yamlContent={yaml}
      onYamlChange={handleYamlChange}
      markdownContent={markdownContent}
      schemaContent={schemaContent}
      onSchemaChange={(newSchema) => {
        setSchemaContent(newSchema);
        // ここにスキーマ保存処理を追加するとよい
      }}
      editorRef={editorRef}
    />
    
    {/* エラーバッジ */}
    {!validationResult.success && (
      <ErrorBadge
        errors={validationResult.errors}
        onClick={handleErrorClick}
      />
    )}
  </div>
)}
```

### 9. WASMをビルドする

- [ ] 変更を適用し、WebAssemblyモジュールを再ビルドします：

```bash
cd packages/core-wasm
./build.sh
```

### 10. テストの作成と実行

- [ ] Rust側のテストを実行します：

```bash
cd packages/core-wasm
cargo test
```

- [ ] TypeScript側のテストファイルを作成します：
  - `apps/web/src/hooks/__tests__/useYamlDiff.test.ts`
  - `apps/web/src/components/__tests__/EditorTabs.test.tsx`
  - `apps/web/src/components/__tests__/ConflictDialog.test.tsx`

- [ ] TypeScriptのテストを実行します：

```bash
cd apps/web
pnpm test
```

- [ ] TypeScriptの型チェックを実行します：

```bash
pnpm typecheck
```

### 11. 手動テスト

- [ ] 開発サーバーを起動してブラウザで手動テストを行います：

```bash
./scripts/dev-start.sh
```

以下の点をテストします：

- [ ] YAMLエディタとMarkdownエディタ間でタブを切り替えて編集できるか
- [ ] 両方のタブで同じフィールドを編集した場合に競合ダイアログが表示されるか
- [ ] 競合ダイアログで「現在のタブの変更を使用」を選択した場合の動作
- [ ] 競合ダイアログで「切り替え先タブの変更を使用」を選択した場合の動作
- [ ] 競合ダイアログで「キャンセル」を選択した場合の動作

## 実装の注意点

1. **複雑なデータ構造の処理**: Markdown⇔YAML変換と差分計算を組み合わせると、複雑なエッジケースが発生する可能性があります。特に、配列や入れ子オブジェクトの変更には注意が必要です。

2. **パフォーマンス考慮**: 差分計算やパッチ適用は比較的コストの高い操作です。大きなドキュメントでもサブミリ秒レベルのレスポンスを維持するため、効率的なアルゴリズムを選択します。

3. **エラーハンドリング**: YAML解析エラーやパッチ適用エラーなど、様々なエラーケースに対する適切なハンドリングを実装します。

4. **ユーザー体験**: 競合ダイアログはユーザーにとって分かりやすく、適切な選択肢を提供する必要があります。テキスト表現だけでなく、視覚的な差分表示も検討するとよいでしょう。

## 次のステップ

フェーズ6bが完了したら、次のフェーズ7ではSchema編集とValidationトグル機能の実装に進みます。差分検出機能は、将来のUndoやバージョン履歴機能のための基盤としても活用できます。