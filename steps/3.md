# Phase 3: リアルタイムバリデーション実装

## 目標

仕様書に記載の通り、Phase 3では以下を実現します：

- useYaml フックの実装 → YAML検証と30msデバウンス
- ErrorBadge コンポーネントの実装 → エラー表示UI

## 1. useYaml hook の実装

### hooks/useYaml.ts の作成

- [ ] WASM初期化のためのuseEffect
  - core-wasm パッケージをロード
  - useState で初期化状態を管理
- [ ] バリデーション関数の実装
  - debounce処理 (30ms)
  - スキーマの読み込み
  - validate_yaml の呼び出し
  - エラー情報の抽出と整形
- [ ] 結果キャッシュの実装
  - パフォーマンス向上のため同一入力の結果をキャッシュ
- [ ] 単体テストの作成
  - Jest/Vitest による mock テスト
  - 様々なバリデーションケースのテスト

### 実装ガイド

```typescript
// hooks/useYaml.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import * as CoreWasm from '@core-wasm';
import { debounce } from 'lodash-es';

// バリデーション結果の型定義
export interface ValidationError {
  line: number;
  message: string;
  path: string;
}

export interface ValidationResult {
  success: boolean;
  errors: ValidationError[];
}

// スキーマパスとその内容のマッピング
const schemaCache = new Map<string, string>();

export function useYaml() {
  // WASM初期化状態
  const [isInitialized, setIsInitialized] = useState(false);
  // 現在の検証結果
  const [validationResult, setValidationResult] = useState<ValidationResult>({ success: true, errors: [] });
  // キャッシュのためのRef
  const lastYaml = useRef<string>('');
  const lastSchema = useRef<string>('');
  const lastResult = useRef<ValidationResult>({ success: true, errors: [] });

  // WASM初期化
  useEffect(() => {
    try {
      // WASMのバージョン確認でロードを検証
      const version = CoreWasm.version();
      console.log(`Core WASM loaded, version: ${version}`);
      setIsInitialized(true);
    } catch (error) {
      console.error('Failed to initialize WASM module:', error);
      setIsInitialized(false);
    }
  }, []);

  // スキーマを読み込む関数
  const loadSchema = useCallback(async (schemaPath: string): Promise<string> => {
    // キャッシュにあればそれを返す
    if (schemaCache.has(schemaPath)) {
      return schemaCache.get(schemaPath)!;
    }

    try {
      const response = await fetch(schemaPath);
      if (!response.ok) {
        throw new Error(`Failed to load schema: ${response.statusText}`);
      }
      const schemaContent = await response.text();
      schemaCache.set(schemaPath, schemaContent);
      return schemaContent;
    } catch (error) {
      console.error('Error loading schema:', error);
      throw error;
    }
  }, []);

  // デバウンスされたバリデーション関数
  const validateYaml = useCallback(
    debounce(async (yaml: string, schemaPath: string) => {
      // 初期化されていなければ何もしない
      if (!isInitialized) {
        console.warn('WASM not initialized yet');
        return;
      }

      // 入力が空なら早期リターン
      if (!yaml.trim()) {
        setValidationResult({ success: true, errors: [] });
        return;
      }

      // 同じ入力なら前回の結果を返す（キャッシュ）
      if (yaml === lastYaml.current && schemaPath === lastSchema.current) {
        setValidationResult(lastResult.current);
        return;
      }

      try {
        // スキーマの読み込み
        const schema = await loadSchema(schemaPath);
        
        // バリデーション実行
        const resultJson = CoreWasm.validate_yaml(yaml, schema);
        const result: ValidationResult = JSON.parse(resultJson);
        
        // 結果の保存
        setValidationResult(result);
        lastYaml.current = yaml;
        lastSchema.current = schemaPath;
        lastResult.current = result;
      } catch (error) {
        console.error('Validation error:', error);
        setValidationResult({
          success: false,
          errors: [{ line: 0, message: `バリデーションエラー: ${error}`, path: '' }]
        });
      }
    }, 30), // 30msのデバウンス
    [isInitialized, loadSchema]
  );

  return {
    isInitialized,
    validateYaml,
    validationResult
  };
}

export default useYaml;
```

### テストファイルの作成

```typescript
// hooks/useYaml.test.ts
import { renderHook, act } from '@testing-library/react';
import { useYaml } from './useYaml';

// CoreWasm モジュールのモック
jest.mock('@core-wasm', () => ({
  version: jest.fn().mockReturnValue('0.1.0'),
  validate_yaml: jest.fn().mockImplementation((yaml, schema) => {
    // 簡単な検証ロジックのモック
    if (yaml.includes('title:')) {
      return JSON.stringify({ success: true, errors: [] });
    } else {
      return JSON.stringify({
        success: false,
        errors: [
          { line: 1, message: 'required property "title" not found', path: '' }
        ]
      });
    }
  })
}));

// global.fetch のモック
global.fetch = jest.fn().mockImplementation((url) => {
  return Promise.resolve({
    ok: true,
    text: () => Promise.resolve('type: object\nproperties:\n  title:\n    type: string\nrequired:\n  - title')
  });
});

describe('useYaml', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should initialize with WASM', async () => {
    const { result, waitForNextUpdate } = renderHook(() => useYaml());
    await waitForNextUpdate();
    expect(result.current.isInitialized).toBe(true);
  });

  it('should validate correct YAML', async () => {
    const { result, waitForNextUpdate } = renderHook(() => useYaml());
    await waitForNextUpdate();

    act(() => {
      result.current.validateYaml('title: Test Note', '/schemas/note.schema.yaml');
    });

    // デバウンスのため少し待つ
    await new Promise(r => setTimeout(r, 50));
    expect(result.current.validationResult.success).toBe(true);
    expect(result.current.validationResult.errors).toHaveLength(0);
  });

  it('should report errors for invalid YAML', async () => {
    const { result, waitForNextUpdate } = renderHook(() => useYaml());
    await waitForNextUpdate();

    act(() => {
      result.current.validateYaml('content: Missing title', '/schemas/note.schema.yaml');
    });

    // デバウンスのため少し待つ
    await new Promise(r => setTimeout(r, 50));
    expect(result.current.validationResult.success).toBe(false);
    expect(result.current.validationResult.errors).toHaveLength(1);
    expect(result.current.validationResult.errors[0].message).toContain('title');
  });
});
```

## 2. ErrorBadge コンポーネントの実装

### components/ErrorBadge.tsx の作成

- [ ] エラーバッジコンポーネントの実装
  - 行番号＋エラーメッセージの表示
  - エラーアイコンとスタイリング
  - ホバー時の詳細情報表示
- [ ] エラーリストの実装
  - 複数エラーがある場合の表示
  - エラーナビゲーション機能

### 実装ガイド

```typescript
// components/ErrorBadge.tsx
import React from 'react';
import { ValidationError } from '../hooks/useYaml';

interface ErrorBadgeProps {
  errors: ValidationError[];
  onClick?: (line: number) => void;
  className?: string;
}

export const ErrorBadge: React.FC<ErrorBadgeProps> = ({ 
  errors, 
  onClick,
  className = '' 
}) => {
  if (errors.length === 0) {
    return null;
  }

  // クリックハンドラー
  const handleClick = (line: number) => {
    if (onClick) {
      onClick(line);
    }
  };

  return (
    <div className={`fixed right-4 bottom-4 z-10 ${className}`}>
      <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded shadow-md max-w-md">
        <div className="flex items-center mb-2">
          <svg className="w-6 h-6 mr-2 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <span className="font-bold">バリデーションエラー ({errors.length})</span>
        </div>
        
        <ul className="text-sm">
          {errors.map((error, index) => (
            <li 
              key={index}
              className="mb-1 cursor-pointer hover:bg-red-200 p-1 rounded"
              onClick={() => handleClick(error.line)}
            >
              {error.line > 0 && <span className="font-mono font-bold">行 {error.line}: </span>}
              {error.message}
              {error.path && <span className="text-xs text-red-600 block ml-4">パス: {error.path}</span>}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default ErrorBadge;
```

## 3. Appコンポーネントの更新

### App.tsx の拡張

- [ ] YAMLEditorとErrorBadge連携のためのApp.tsx更新
  - useYaml hookの統合
  - エラー情報の表示設定
  - エラークリック時のエディタ連携

### 実装ガイド

```typescript
import React, { useState, useCallback, useRef } from 'react';
import YamlEditor from './components/YamlEditor';
import ErrorBadge from './components/ErrorBadge';
import useFileAccess from './hooks/useFileAccess';
import useYaml from './hooks/useYaml';

const defaultYaml = `title: My YAML Note
content: |
  Enter your note content here.
  
  ## This supports markdown
  
  - List items
  - More items
tags:
  - yaml
  - note
created_at: "${new Date().toISOString()}"
updated_at: "${new Date().toISOString()}"
metadata:
  author: YAML Note User
  version: 1.0
  status: draft`;

const App: React.FC = () => {
  const [yaml, setYaml] = useState<string>(defaultYaml);
  const [isSaved, setIsSaved] = useState<boolean>(true);
  const { fileName, isSupported, openFile, saveFile } = useFileAccess();
  const { validateYaml, validationResult } = useYaml();
  const editorRef = useRef<any>(null);

  // YAML変更時の処理
  const handleYamlChange = useCallback((newValue: string) => {
    setYaml(newValue);
    setIsSaved(false);
    validateYaml(newValue, '/packages/schemas/note.schema.yaml');
  }, [validateYaml]);

  // ファイルを開く処理
  const handleOpenFile = useCallback(async () => {
    try {
      const fileInfo = await openFile();
      if (fileInfo) {
        setYaml(fileInfo.content);
        validateYaml(fileInfo.content, '/packages/schemas/note.schema.yaml');
        setIsSaved(true);
      }
    } catch (error) {
      console.error('Error opening file:', error);
      alert('ファイルを開く際にエラーが発生しました');
    }
  }, [openFile, validateYaml]);

  // ファイルを保存する処理
  const handleSaveFile = useCallback(async () => {
    try {
      const success = await saveFile(yaml);
      if (success) {
        setIsSaved(true);
      }
    } catch (error) {
      console.error('Error saving file:', error);
      alert('ファイルの保存中にエラーが発生しました');
    }
  }, [saveFile, yaml]);

  // エラーバッジクリック時のエディタ行移動
  const handleErrorClick = useCallback((line: number) => {
    if (editorRef.current && line > 0) {
      editorRef.current.setCursor(line - 1);
    }
  }, []);

  // マウント時に初回バリデーション
  React.useEffect(() => {
    validateYaml(yaml, '/packages/schemas/note.schema.yaml');
  }, [validateYaml, yaml]);

  return (
    <div className="flex flex-col h-screen bg-slate-100 p-4">
      <header className="flex justify-between items-center mb-4">
        <h1 className="text-2xl font-bold text-gray-800">YAML Note MVP</h1>
        
        <div className="flex gap-2">
          <button
            onClick={handleOpenFile}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300"
          >
            Open
          </button>
          <button
            onClick={handleSaveFile}
            disabled={isSaved}
            className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:bg-gray-300"
          >
            Save {!isSaved && '*'}
          </button>
        </div>
      </header>
      
      <div className="flex-1 mb-4 relative">
        <YamlEditor
          value={yaml}
          onChange={handleYamlChange}
          className="h-full"
          editorRef={editorRef}
        />
        
        {/* エラーバッジ */}
        {!validationResult.success && (
          <ErrorBadge 
            errors={validationResult.errors} 
            onClick={handleErrorClick}
          />
        )}
      </div>
      
      <footer className="flex justify-between text-sm text-gray-500">
        <div>{fileName || 'Unsaved document'}</div>
        <div>
          {isSaved ? 'Saved' : 'Unsaved changes'} 
          {validationResult.success 
            ? ' • Valid YAML' 
            : ` • ${validationResult.errors.length} error(s)`}
        </div>
      </footer>
    </div>
  );
};

export default App;
```

### YamlEditor.tsx の更新

```typescript
import React, { useCallback, forwardRef, useImperativeHandle, useRef } from 'react';
import CodeMirror from '@uiw/react-codemirror';
import { yaml } from '@codemirror/lang-yaml';
import { EditorView } from '@codemirror/view';

interface YamlEditorProps {
  value: string;
  onChange: (value: string) => void;
  className?: string;
  editorRef?: React.Ref<{
    setCursor: (line: number) => void;
  }>;
}

export const YamlEditor: React.FC<YamlEditorProps> = forwardRef(({ 
  value, 
  onChange,
  className = '',
  editorRef
}, ref) => {
  const editorViewRef = useRef<EditorView | null>(null);

  const handleChange = useCallback((value: string) => {
    onChange(value);
  }, [onChange]);

  const handleEditorCreate = useCallback((view: EditorView) => {
    editorViewRef.current = view;
  }, []);

  // REF APIの実装
  useImperativeHandle(editorRef, () => ({
    setCursor: (line: number) => {
      if (editorViewRef.current) {
        const state = editorViewRef.current.state;
        const lines = state.doc.lines;
        
        if (line >= 0 && line < lines) {
          const pos = state.doc.line(line + 1).from;
          
          // カーソル位置の設定とスクロール位置の調整
          const transaction = state.update({
            selection: { anchor: pos, head: pos },
            scrollIntoView: true,
          });
          
          editorViewRef.current.dispatch(transaction);
          editorViewRef.current.focus();
        }
      }
    }
  }), []);

  return (
    <div className={`h-full w-full border border-gray-300 rounded overflow-hidden ${className}`}>
      <CodeMirror
        value={value}
        height="100%"
        extensions={[
          yaml(),
          EditorView.lineWrapping,
        ]}
        onChange={handleChange}
        onCreateEditor={handleEditorCreate}
        theme="light"
        basicSetup={{
          lineNumbers: true,
          highlightActiveLine: true,
          highlightSelectionMatches: true,
          foldGutter: true,
          autocompletion: true,
          indentOnInput: true,
        }}
      />
    </div>
  );
});

export default YamlEditor;
```

## 4. テスト方法

### 単体テスト

- [ ] useYaml.test.ts の実行
  - `pnpm test` コマンドを実行
  - mockedなテストがパスすることを確認

### 手動テスト

- [ ] 開発サーバーの起動
  - `./scripts/dev-start.sh` を実行
- [ ] 不正なYAMLの入力
  - タイトルを削除してrequiredエラーが表示されるか確認
  - 意図的に不正なインデントを入れてエラーが表示されるか確認
- [ ] エラーバッジの確認
  - エラー時に赤いバッジが表示され、クリックするとエディタの該当行にカーソルが移動するか確認

## 完了条件

- [ ] `pnpm test` でuseYamlとErrorBadgeのテストがパスすること
- [ ] 開発サーバーで動作を確認し、YAMLエディタでエラーを即時検知できること
- [ ] エラーバッジがクリックできてエディタとの連携が機能すること
- [ ] 以下のファイルが作成され、正常に動作すること:
  - hooks/useYaml.ts
  - components/ErrorBadge.tsx
  - 更新されたApp.tsxとYamlEditor.tsx

## 残課題

- [ ] エラー表示のスタイル調整と改善
- [ ] 複数スキーマに対応するためのスキーマ選択機能
- [ ] エラー位置のハイライト表示強化