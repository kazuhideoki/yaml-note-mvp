# Phase 5: UXログ機能実装

## 目標

仕様書に記載の通り、Phase 5では以下を実現します：

- ユーザー操作のログ収集基盤の構築
- UX改善のためのアクションログ実装
- プライバシーに配慮したログ設計

## 1. ログシステムの設計

### ログの種類と目的の明確化

- [x] アクションログの定義
  - ユーザー操作（編集、保存、開く、エラー、表示モード切替など）
  - パフォーマンス指標（読み込み時間、レンダリング時間など）
  - エラー状況（バリデーションエラー、パース失敗など）

- [x] プライバシー設計
  - 個人情報を含まないログ設計
  - コンテンツのハッシュ化やサマリー化
  - ユーザーオプトアウト機能

## 2. ログコンテキストの実装

### hooks/useLogger.ts の作成

- [x] Contextプロバイダーの実装
  - ログレベル（debug, info, warn, error）
  - セッション識別子
  - プラットフォーム情報

```typescript
// hooks/useLogger.ts
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { v4 as uuidv4 } from 'uuid';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogEvent {
  timestamp: number;
  level: LogLevel;
  action: string;
  details?: Record<string, any>;
  sessionId: string;
}

interface LoggerContextType {
  log: (level: LogLevel, action: string, details?: Record<string, any>) => void;
  events: LogEvent[];
  clearEvents: () => void;
  sessionId: string;
}

const LoggerContext = createContext<LoggerContextType | null>(null);

export const LoggerProvider = ({ children }: { children: ReactNode }) => {
  const [events, setEvents] = useState<LogEvent[]>([]);
  const [sessionId] = useState<string>(() => uuidv4());
  
  // プラットフォーム情報の収集
  const [platformInfo] = useState(() => ({
    userAgent: navigator.userAgent,
    screenSize: `${window.innerWidth}x${window.innerHeight}`,
    language: navigator.language,
  }));
  
  // セッション開始ログ
  useEffect(() => {
    logEvent('info', 'session_start', { platformInfo });
    
    return () => {
      logEvent('info', 'session_end', {
        duration: Date.now() - events[0]?.timestamp || 0,
      });
    };
  }, []);
  
  const logEvent = (level: LogLevel, action: string, details?: Record<string, any>) => {
    const event: LogEvent = {
      timestamp: Date.now(),
      level,
      action,
      details,
      sessionId
    };
    
    setEvents(prev => [...prev, event]);
    
    // 開発環境ではコンソールにも出力
    if (process.env.NODE_ENV === 'development') {
      console.log(`[${level.toUpperCase()}] ${action}`, details || '');
    }
  };
  
  const clearEvents = () => {
    setEvents([]);
  };
  
  return (
    <LoggerContext.Provider value={{ 
      log: logEvent, 
      events,
      clearEvents,
      sessionId
    }}>
      {children}
    </LoggerContext.Provider>
  );
};

export const useLogger = () => {
  const context = useContext(LoggerContext);
  
  if (!context) {
    throw new Error('useLogger must be used within a LoggerProvider');
  }
  
  return context;
};

export default useLogger;
```

### LoggerProvider の統合

- [x] ルートコンポーネントへの統合
  - main.tsx での Provider 設定
  - 開発モードとプロダクションモードの分離

```typescript
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { LoggerProvider } from './hooks/useLogger';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <LoggerProvider>
      <App />
    </LoggerProvider>
  </React.StrictMode>
);
```

## 3. ログイベントの設計と実装

### ログイベントの定義

- [x] 主要操作ログの実装
  - エディタアクション（`editor_change`, `editor_focus`, `editor_cursor_move`）
  - ファイル操作（`file_open`, `file_save`, `file_save_error`）
  - 検証関連（`validation_success`, `validation_error`）
  - レイアウト操作（`layout_change`, `view_mode_change`）

### ユーティリティ関数の実装

- [x] ログデータ加工ユーティリティの作成
  - コンテンツのサマリー化関数（プライバシー配慮）
  - エラーオブジェクトの整形
  - パフォーマンス計測用ヘルパー

```typescript
// src/utils/logUtils.ts
export const summarizeContent = (content: string): string => {
  // プライバシーを保護するためコンテンツのサマリーのみを作成
  const byteLength = new Blob([content]).size;
  
  // 行数とバイト数を含む概要情報のみ返す
  const lineCount = content.split('\n').length;
  
  return JSON.stringify({
    byteLength,
    lineCount,
    hasTitle: content.includes('title:'),
    hasContent: content.includes('content:'),
  });
};

export const formatError = (error: any): Record<string, any> => {
  if (!error) return { message: 'Unknown error' };
  
  return {
    message: error.message || 'No message',
    name: error.name || 'Error',
    // スタックトレースはオプション（開発時のみなど）
    ...(process.env.NODE_ENV === 'development' ? { stack: error.stack } : {})
  };
};

export const createPerformanceMarker = (actionName: string) => {
  const startTime = performance.now();
  
  return () => {
    const endTime = performance.now();
    return {
      action: actionName,
      duration: endTime - startTime,
      start: startTime,
      end: endTime
    };
  };
};
```

## 4. コンポーネントへのログ統合

### App.tsx の拡張

- [x] 主要コンポーネントへのロガー統合
  - ファイル操作時のログ追加
  - モード切り替え時のログ追加
  - エラー発生時のログ追加

```typescript
// App.tsx でのログ統合例
import useLogger from './hooks/useLogger';
import { summarizeContent, createPerformanceMarker } from './utils/logUtils';

// 既存のコード...

const App: React.FC = () => {
  // 既存の状態...
  const { log } = useLogger();
  
  // YAML変更時の処理
  const handleYamlChange = useCallback((newValue: string) => {
    setYaml(newValue);
    setIsSaved(false);
    
    // 変更のログ記録
    log('info', 'editor_change', {
      content_summary: summarizeContent(newValue),
      changed_characters: Math.abs(newValue.length - yaml.length),
    });
    
    // パフォーマンス計測とログ記録
    const endMeasure = createPerformanceMarker('yaml_validation');
    validateYaml(newValue, schemaPath);
    
    const perfData = endMeasure();
    if (perfData.duration > 100) {
      // 100ms以上かかる場合のみログ記録（例）
      log('debug', 'performance', perfData);
    }
  }, [yaml, validateYaml, log]);
  
  // ファイルを開く処理
  const handleOpenFile = useCallback(async () => {
    log('info', 'file_open_start');
    
    try {
      const fileInfo = await openFile();
      if (fileInfo) {
        setYaml(fileInfo.content);
        validateYaml(fileInfo.content, schemaPath);
        setIsSaved(true);
        
        log('info', 'file_open_success', {
          content_summary: summarizeContent(fileInfo.content),
          filename: fileInfo.name
        });
      }
    } catch (error) {
      console.error('Error opening file:', error);
      log('error', 'file_open_error', { error: formatError(error) });
      alert('ファイルを開く際にエラーが発生しました');
    }
  }, [openFile, validateYaml, log]);
  
  // ビューモード変更時に記録
  const handleViewModeChange = (mode: ViewMode) => {
    setViewMode(mode);
    localStorage.setItem('yaml-note-view-mode', mode);
    
    log('info', 'view_mode_change', { mode });
  };
  
  // ...その他コード
};
```

### YamlEditor.tsx の拡張

- [x] エディタコンポーネントのログ実装
  - カーソル移動ログ
  - フォーカスイベントログ
  - パフォーマンス計測

```typescript
// components/YamlEditor.tsx でのログ統合例
import { useLogger } from '../hooks/useLogger';
import { createPerformanceMarker } from '../utils/logUtils';

export const YamlEditor: React.FC<YamlEditorProps> = forwardRef(({
  // 既存のプロパティ...
}, ref) => {
  const editorViewRef = useRef<EditorView | null>(null);
  const { log } = useLogger();

  const handleChange = useCallback((value: string) => {
    onChange(value);
  }, [onChange]);

  const handleEditorCreate = useCallback((view: EditorView) => {
    editorViewRef.current = view;
    
    // エディタ初期化のログ
    log('debug', 'editor_initialized');
    
    // カーソル移動のログ記録（スロットル処理推奨）
    view.dom.addEventListener('keyup', () => {
      const state = view.state;
      const selection = state.selection;
      
      if (selection) {
        log('debug', 'editor_cursor_move', {
          position: {
            from: selection.main.from,
            to: selection.main.to,
            line: state.doc.lineAt(selection.main.from).number
          }
        });
      }
    });
    
    // フォーカスイベントの記録
    view.dom.addEventListener('focus', () => {
      log('debug', 'editor_focus', { state: 'gained' });
    });
    
    view.dom.addEventListener('blur', () => {
      log('debug', 'editor_focus', { state: 'lost' });
    });
  }, [log]);

  // その他既存コード...
});
```

## 5. ログデータの永続化

### ログエクスポート機能の実装

- [x] ローカルストレージの活用
  - ログの一時保存
  - セッション間の永続化

```typescript
// ログの保存と復元
useEffect(() => {
  // 一定間隔でログをローカルストレージに保存
  const saveInterval = setInterval(() => {
    if (events.length > 0) {
      // 過去のログと結合
      const storedLogs = JSON.parse(localStorage.getItem('yaml_note_logs') || '[]');
      const updatedLogs = [...storedLogs, ...events];
      
      // サイズ制限（例: 最新1000件のみ保持）
      const trimmedLogs = updatedLogs.slice(-1000);
      
      localStorage.setItem('yaml_note_logs', JSON.stringify(trimmedLogs));
      clearEvents(); // メモリ内のログをクリア
    }
  }, 60000); // 1分ごと
  
  return () => clearInterval(saveInterval);
}, [events, clearEvents]);
```

### ログ確認画面の作成 (オプション)

- [x] 開発者向けログビューア
  - ログの表示とフィルタリング
  - ログのエクスポート機能
  - パフォーマンス分析表示

```typescript
// components/DevLogViewer.tsx
import React, { useState } from 'react';
import useLogger, { LogEvent, LogLevel } from '../hooks/useLogger';

interface DevLogViewerProps {
  onClose: () => void;
}

const DevLogViewer: React.FC<DevLogViewerProps> = ({ onClose }) => {
  const { events } = useLogger();
  const [filter, setFilter] = useState<LogLevel | 'all'>('all');
  
  const filteredEvents = filter === 'all' 
    ? events 
    : events.filter(event => event.level === filter);
  
  const handleExport = () => {
    const exportData = JSON.stringify(events, null, 2);
    const blob = new Blob([exportData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `yaml-note-logs-${new Date().toISOString()}.json`;
    a.click();
    
    URL.revokeObjectURL(url);
  };
  
  return (
    <div className="fixed inset-0 bg-gray-800 bg-opacity-75 z-50 flex items-center justify-center">
      <div className="bg-white rounded-lg w-3/4 h-3/4 p-4 flex flex-col">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">開発者ログビューア</h2>
          <div className="flex gap-2">
            <select 
              value={filter} 
              onChange={e => setFilter(e.target.value as LogLevel | 'all')}
              className="border rounded px-2 py-1"
            >
              <option value="all">すべて</option>
              <option value="debug">Debug</option>
              <option value="info">Info</option>
              <option value="warn">Warning</option>
              <option value="error">Error</option>
            </select>
            <button 
              onClick={handleExport} 
              className="bg-blue-500 text-white px-3 py-1 rounded"
            >
              エクスポート
            </button>
            <button 
              onClick={onClose} 
              className="bg-red-500 text-white px-3 py-1 rounded"
            >
              閉じる
            </button>
          </div>
        </div>
        
        <div className="flex-1 overflow-auto border rounded">
          <table className="w-full text-left">
            <thead className="bg-gray-100 sticky top-0">
              <tr>
                <th className="p-2">時間</th>
                <th className="p-2">レベル</th>
                <th className="p-2">アクション</th>
                <th className="p-2">詳細</th>
              </tr>
            </thead>
            <tbody>
              {filteredEvents.map((event, index) => (
                <tr key={index} className="border-b">
                  <td className="p-2 font-mono">
                    {new Date(event.timestamp).toLocaleTimeString()}
                  </td>
                  <td className={`p-2 ${
                    event.level === 'error' ? 'text-red-500' :
                    event.level === 'warn' ? 'text-yellow-500' :
                    event.level === 'info' ? 'text-blue-500' :
                    'text-gray-500'
                  }`}>
                    {event.level.toUpperCase()}
                  </td>
                  <td className="p-2">{event.action}</td>
                  <td className="p-2 font-mono text-xs">
                    {event.details 
                      ? JSON.stringify(event.details, null, 2) 
                      : ''}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default DevLogViewer;
```

## 6. テスト方法

### 単体テスト

- [x] useLogger.test.ts の作成
  - ログ記録のテスト
  - コンテキストの正しい動作確認
  - ユーティリティ関数のテスト

```typescript
// hooks/__tests__/useLogger.test.ts
import { renderHook, act } from '@testing-library/react-hooks';
import { LoggerProvider, useLogger } from '../useLogger';
import React from 'react';

describe('useLogger', () => {
  it('should record log events', () => {
    const wrapper = ({ children }) => (
      <LoggerProvider>{children}</LoggerProvider>
    );
    
    const { result } = renderHook(() => useLogger(), { wrapper });
    
    act(() => {
      result.current.log('info', 'test_action', { test: true });
    });
    
    expect(result.current.events).toHaveLength(1);
    expect(result.current.events[0]).toMatchObject({
      level: 'info',
      action: 'test_action',
      details: { test: true },
    });
    
    act(() => {
      result.current.log('error', 'error_action');
    });
    
    expect(result.current.events).toHaveLength(2);
    expect(result.current.events[1].level).toBe('error');
  });
  
  it('should generate consistent session ID', () => {
    const wrapper = ({ children }) => (
      <LoggerProvider>{children}</LoggerProvider>
    );
    
    const { result, rerender } = renderHook(() => useLogger(), { wrapper });
    
    const initialSessionId = result.current.sessionId;
    expect(initialSessionId).toBeTruthy();
    
    rerender();
    
    expect(result.current.sessionId).toBe(initialSessionId);
  });
  
  it('should clear events on demand', () => {
    const wrapper = ({ children }) => (
      <LoggerProvider>{children}</LoggerProvider>
    );
    
    const { result } = renderHook(() => useLogger(), { wrapper });
    
    act(() => {
      result.current.log('info', 'test1');
      result.current.log('info', 'test2');
    });
    
    expect(result.current.events).toHaveLength(2);
    
    act(() => {
      result.current.clearEvents();
    });
    
    expect(result.current.events).toHaveLength(0);
  });
});
```

### ユーティリティ関数テスト

- [x] logUtils.test.ts の作成
  - サマリー関数のテスト
  - エラーフォーマット関数のテスト
  - パフォーマンスマーカーのテスト

```typescript
// utils/__tests__/logUtils.test.ts
import { summarizeContent, formatError, createPerformanceMarker } from '../logUtils';

describe('logUtils', () => {
  describe('summarizeContent', () => {
    it('should summarize content correctly', () => {
      const content = `title: Test
content: |
  ## Heading
  Some test content
  - Item 1
  - Item 2`;
      
      const summary = JSON.parse(summarizeContent(content));
      
      expect(summary.lineCount).toBe(7);
      expect(summary.hasTitle).toBe(true);
      expect(summary.hasContent).toBe(true);
      expect(summary.byteLength).toBeGreaterThan(0);
    });
  });
  
  describe('formatError', () => {
    it('should format standard error objects', () => {
      const error = new Error('Test error');
      const formatted = formatError(error);
      
      expect(formatted.message).toBe('Test error');
      expect(formatted.name).toBe('Error');
    });
    
    it('should handle non-standard error objects', () => {
      const error = { message: 'Custom error' };
      const formatted = formatError(error);
      
      expect(formatted.message).toBe('Custom error');
    });
    
    it('should handle null/undefined errors', () => {
      const formatted = formatError(null);
      
      expect(formatted.message).toBe('Unknown error');
    });
  });
  
  describe('createPerformanceMarker', () => {
    it('should measure elapsed time', async () => {
      const endMeasure = createPerformanceMarker('test_action');
      
      // 少し待機
      await new Promise(r => setTimeout(r, 50));
      
      const result = endMeasure();
      
      expect(result.action).toBe('test_action');
      expect(result.duration).toBeGreaterThanOrEqual(40); // 少し余裕を持たせる
      expect(result.start).toBeLessThan(result.end);
    });
  });
});
```

## 7. アクション実装チェックリスト

以下のコンポーネントとアクションへのログ実装を確認します：

- [x] App.tsx
  - [x] ファイル操作ログ (`file_open`, `file_save`)
  - [x] バリデーションログ (`validation_success`, `validation_error`)
  - [x] 表示モード変更ログ (`view_mode_change`)

- [x] YamlEditor.tsx
  - [x] エディタ変更ログ (`editor_change`)
  - [x] カーソル移動ログ (`editor_cursor_move`)
  - [x] フォーカスイベントログ (`editor_focus`)

- [x] ErrorBadge.tsx
  - [x] エラークリックログ (`error_badge_click`)

- [x] MarkdownPreview.tsx
  - [x] レンダリングパフォーマンスログ (`markdown_render_performance`)

## 8. パフォーマンス向上

### ログ最適化

- [x] スロットル/デバウンス実装
  - 高頻度イベントのスロットル処理
  - バッチ処理の検討

```typescript
// utils/throttle.ts
export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let lastCall = 0;
  
  return (...args: Parameters<T>) => {
    const now = Date.now();
    
    if (now - lastCall >= limit) {
      lastCall = now;
      func(...args);
    }
  };
};

// エディタでの使用例
const throttledCursorMove = throttle((position) => {
  log('debug', 'editor_cursor_move', { position });
}, 500); // 500ms間隔でスロットル
```

## 完了条件

- [x] ログのコンテキストシステムが正しく動作すること
  - セッションIDが生成され、すべてのログに含まれること
  - LoggerProviderが正しく設定されていること

- [x] ログが少なくとも以下のアクションに実装されていること
  - ファイル操作（開く、保存）
  - エディタ操作（変更、移動）
  - バリデーション結果
  - レイアウト変更

- [x] テストが成功すること
  - useLogger.test.ts のすべてのテスト
  - logUtils.test.ts のすべてのテスト

- [x] プライバシーに配慮すること
  - ログにユーザーコンテンツそのものが含まれないこと
  - ファイル名などの機微情報が適切に処理されていること

## 残課題と将来拡張

- [ ] ログの統計分析機能
- [ ] リモートログサーバーへの送信
- [ ] ヒートマップなどのUX分析ツール連携
- [ ] A/Bテスト基盤としての拡張
- [ ] ログレベル設定のユーザー制御